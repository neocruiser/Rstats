\documentclass[9pt,english]{extarticle}
\include{canevas_config}

\begin{document}
\author{Sleiman Bassim, PhD}
\title{R implementation}
\maketitle
\begin{linenumbers}
<<setup, include=FALSE, cache=FALSE>>=
# set global chunk options
opts_chunk$set(dev="postscript",
               fig.path="graphics/plot",
               fig.lp= "",
               comment=NA,
               fig.keep="high",
               fig.show='hold',
               fig.align='center', 
               out.width='.49\\textwidth',
               tidy.source=TRUE,
               crop=TRUE,
               results="markup",
               warnings=FALSE,
               error=FALSE,
               message=FALSE)
options(formatR.arrow=TRUE,
        width=70,
        digits = 3,
        scipen = 6)
@ 

\noindent
\marginnote{\small\color{blue}$\Lsh$ Project started July 10 2015}[.1cm]
Loaded functions:
<<loading,results=FALSE>>=
#source("/media/Data/Dropbox/humanR/01funcs.R")
rm(list=ls())
@ 

Load packages.
<<packages, results='hide'>>=
pkgs <- c('xlsx','caret','leaps','glmnet','lattice','latticeExtra',
          'ggplot2', 'dplyr', 'tidyr')
lapply(pkgs, require, character.only = TRUE)
@

\section{Quality controls and preprocessing}
\label{subsec:trim}
Many different options are available while trimming reads.
\begin{itemize}
\item Nature of PCR adapters (trueSeq2 or trueSeq3)
\item Sliding window while reading contigs
\item Crop less than a desired read length
\item Minimum length for reads
\item Trailing while removing the ends of reads with low quality
\end{itemize}

Different trimming options were tested. Iterations were run on combination of the trimming options.
The plot shows the number of reads remaining after trimming using different adapters and a combination of trimming parameters (shapes).
The \textit{default} parameters includes clipping low quality segments and size of reads. The \textit{slide} option include frameshiftting while filtering out low quality reads and the defaults. The \textit{crop} option includes trimming the end of the reads and the defaults. The \textit{slcrop} option includes sliding and cropping and the defaults. The \textit{default2} parameters reliy on using different adapters for paired end sequencing. The \textit{slide2} option include frameshiftting with the default parameters and different set of adapters.
<<chartrim>>=
trim <- read.xlsx("./data/Classeur1.xlsx", header = T, sheetName = "Feuil1")
trim <- trim[1:3, ]
key.variety <- list(space = "right", 
                    text = list(colnames(trim[, -c(1:2)])), 
                    points = list(pch = c(15:18,25,4)))

dotplot(c(trim$Total-trim$default)/100000 +
           c(trim$Total-trim$slide)/100000 + 
               c(trim$Total-trim$crop)/100000 +
                   c(trim$Total-trim$slcrop)/100000 +
                       c(trim$Total-trim$default2)/100000 +
                           c(trim$Total-trim$slide2)/100000
       ~ trim$Sample,
       data = trim,
       type = 'o',
        pch = c(15:18,25,4),
        key = key.variety,
        lty = 1, cex = 1.5, 
       xlab = 'Nodule samples',
       ylab = 'Discarded reads x 100,000')

@ 

Another way to visualize the discarded reads. A1 = yellow, A2 = orange, A3 = red.
<<trim2>>=
custom.colors <- c(col1 = "#ffeda0", col2 = "#feb24c", col3 = "#f03b20")

barplot(as.matrix((trim$Total-trim[, -c(1:2)])/100000),
        horiz = TRUE,
        col = custom.colors,
        xlab = 'Discarded reads x 100,000',
        ylab = 'Protocols for trimming',
        las = 2)
@ 


\section{Mapping reads to reference}
\label{subsec:align}

Two sets of reads were mapped to 3 different assembled references.
\marginnote{\small\color{blue}$\Lsh$ The references v017 and genome v21 are test references, while genome v015 is the one used in the published work.}[.1cm]
First batch from the trimmed reads with the default parameters (adapters clipping, trailing, and minimum length) and TrueSeq3 adapters.
Second batch were also trimmed with default settings but using TrueSeq2 adapters.
With the second batch of adapters, more reads were trimmed and discarded. This analysis will try to show the regression of mapped reads to the length of each reference.
<<map>>=
ref.genome1 <- read.table("./data/refGenome/A1.htseq.counts.txt")
ref.genome2 <- read.table("./data/refGenome/A2.htseq.counts.txt")
ref.genome3 <- read.table("./data/refGenome/A3.htseq.counts.txt")
ref.genome4 <- read.table("./data/refGenome/A1-4.htseq.counts.txt")
ref.genome5 <- read.table("./data/refGenome/A2-4.htseq.counts.txt")
ref.genome6 <- read.table("./data/refGenome/A3-4.htseq.counts.txt")
@ 

Merge by reference position all the mapped reads from different trimming options.
<<mapx2>>=
ref.genome <- data.frame(
    A1 = ref.genome1[-c(556:560), 2],
    A2 = ref.genome2[-c(556:560), 2],
    A3 = ref.genome3[-c(556:560), 2],
    A1.4 = ref.genome4[-c(556:560), 2],
    A2.4 = ref.genome5[-c(556:560), 2],
    A3.4 = ref.genome6[-c(556:560), 2],
    contigs = ref.genome1[-c(556:560), 1])
dim(ref.genome)
genome <- read.table("./data/QPX_Genome_v017.gff3")
genome1 <- data.frame(contigs= genome[,1], length = genome$V5)
@

Merge by reference position the length and number of mapped reads.
\marginnote{\small\color{blue}$\Lsh$ Data are from trimming with TrueSeq3 (selected) and TrueSeq2 (testing). We only plot TrueSeq3.}[.1cm]
<<mapx3>>=
ref.genome.mix <- merge(genome1, ref.genome)
head(ref.genome.mix)
@ 

Correlation between read length and number of mapped reads on the (testing) genome of QPX with the remaining reads from the default trimming with TrueSeq3 adapters.
<<map2>>=
custom.colors <- c('#d7191c', '#abdda4', '#2b83ba')
key.variety <- list(space = "right", 
                    text = list(colnames(ref.genome.mix[, 3:5])),
                    col = custom.colors)
xyplot(A1 + A2 + A3 ~ length, 
       data = ref.genome.mix,
       xlab = 'Length of contigs in reference Genome (total 555)',
       ylab = 'Nb of mapped reads from nodule samples (log10)',
       col = custom.colors,
       cex = 0.5,
       type = c("g", "p", "smooth"), 
       scales = list(log = 10),
       key = key.variety)
      
@ 


Regression between reads and length of contigs in reference genome with (testing) adapters TrueSeq2 under default trimming settings.
<<map3>>=
custom.colors <- c('#d7191c', '#abdda4', '#2b83ba')
key.variety <- list(space = "right", 
                    text = list(colnames(ref.genome.mix[, 6:8])),
                    col = custom.colors)
xyplot(A1.4 + A2.4 + A3.4 ~ length, 
#                   alpha = .5,
       data = ref.genome.mix,
       xlab = 'Length of contigs in reference Genome (total 555)',
       ylab = 'Nb of mapped reads from nodule samples (log10)',
       col = custom.colors,
       cex = 0.5,
       type = c("g", "p", "smooth"), 
       scales = list(log = 10),
       key = key.variety)
      
@ 

Previously we regressed the number of mapped reads over the reference genome (v21) of QPX.
Now its time to do the same thing over the reference transcriptome of QPX (v17).
Both references belong the Steve Roberts.
<<trans>>=
ref.transcriptome1 <- read.table("./data/refTranscriptome/A1.htseq.counts.txt")
ref.transcriptome2 <- read.table("./data/refTranscriptome/A2.htseq.counts.txt")
ref.transcriptome3 <- read.table("./data/refTranscriptome/A3.htseq.counts.txt")
ref.transcriptome4 <- read.table("./data/refTranscriptome/A1-4.htseq.counts.txt")
ref.transcriptome5 <- read.table("./data/refTranscriptome/A2-4.htseq.counts.txt")
ref.transcriptome6 <- read.table("./data/refTranscriptome/A3-4.htseq.counts.txt")
dim(ref.transcriptome1)
tail(ref.transcriptome1)
@ 

Merge by the position on the reference transcriptome all the mapped reads.
\marginnote{\small\color{blue}$\Lsh$ Data is from trimming with TrueSeq3 (selected) and TrueSeq2 (testing). We only plot TruSeq3}[.1cm]
<<trans2>>=
ref.transcriptome <- data.frame(
    A1 = ref.transcriptome1[-c(11775:11779), 2],
    A2 = ref.transcriptome2[-c(11775:11779), 2],
    A3 = ref.transcriptome3[-c(11775:11779), 2],
    A1.4 = ref.transcriptome4[-c(11775:11779), 2],
    A2.4 = ref.transcriptome5[-c(11775:11779), 2],
    A3.4 = ref.transcriptome6[-c(11775:11779), 2],
    contigs = ref.transcriptome1[-c(11775:11779), 1])
dim(ref.transcriptome)
head(ref.transcriptome)
transcriptome <- read.table("./data/QPX_transcriptome_v2orf.gff3")
transcriptome1 <- data.frame(contigs= transcriptome[,1], length = transcriptome$V5)
@ 

Merge by the position on the reference transcriptome the length and number of the mapped reads.
<<trans3>>=
ref.transcriptome.mix <- merge(transcriptome1, ref.transcriptome)
head(ref.transcriptome.mix)
@ 


Plot the correlation between read length and number of mapped reads on the transcriptome of QPX with the remaining reads from the default trimming with TrueSeq3 adapters.
<<trans4>>=
custom.colors <- c('#d7191c', '#abdda4', '#2b83ba')
key.variety <- list(space = "right", 
                    text = list(colnames(ref.transcriptome.mix[, 3:5])),
                    col = custom.colors)
xyplot(A1 + A2 + A3 ~ length, 
       data = ref.transcriptome.mix,
       xlab = 'Length of contigs in reference transcriptome',
       ylab = 'Nb of mapped reads from nodule samples (log10)',
       col = custom.colors,
       cex = 0.5,
       type = c("g", "p", "smooth"), 
       scales = list(log = 10),
       key = key.variety)
      
@ 
\subsection{Concentration of contigs in different libraries}
\label{subsec:density}
Density plot between reference transcriptome and assembled contigs. The plot shows a high concentration of contigs under 2000 base pair. Trimming parameters are of default with TrueSeq3 adapters.
<<trans1>>=
custom.colors <- c('#d7191c', '#abdda4', '#2b83ba')
key.variety <- list(space = "right", 
                    text = list(colnames(ref.genome.mix[, 3:5])),
                    col = custom.colors)
densityplot(A1 + A2 + A3 ~ length, 
       data = ref.transcriptome.mix,
#            alpha = .7,
            xlab = 'Length of contigs in reference transcriptome v017 (total 11774)',
       ylab = 'Nb of mapped reads from nodule samples',
       col = custom.colors,
       cex = 0.5,
       type = c("g", "p", "smooth"), 
#       scales = list(log = 10),
       key = key.variety)

@ 

Plot correlation same as above but with TrueSeq2 adapters with default parameters.
<<trans2x>>=
custom.colors <- c('#d7191c', '#abdda4', '#2b83ba')
key.variety <- list(space = "right", 
                    text = list(colnames(ref.genome.mix[, 6:8])),
                    col = custom.colors)
densityplot(A1.4 + A2.4 + A3.4 ~ length, 
       data = ref.transcriptome.mix,
#            alpha = .9,
       xlab = 'Length of contigs in reference transcriptome v017 (total 11774)',
       ylab = 'Nb of mapped reads from nodule samples (log10)',
       col = custom.colors,
       cex = 0.5,
       type = c("g", "p", "smooth"), 
       scales = list(log = 10),
       key = key.variety)
@ 


\subsection{Testing contig length and mapping with different assembled references}
\label{subsec:references}
\marginnote{\small\color{blue}$\Lsh$ MMETSP is a project for sequencing different strains of QPX. MMETSP0098 and MMETPS00992 were used here. Both strains come fron New York and Virginia respectively. Official project can be found \href{https://goo.gl/xnpgdt}{here}.}[.1cm]
Load the number of mapped reads to the MMETSP0098 transcriptome before discarding duplicates.
<<prediscardR3>>=
ref.dupA1R3 <- read.table("./data/refMME98/A1.htseq.counts.txt")
ref.dupA2R3 <- read.table("./data/refMME98/A2.htseq.counts.txt")
ref.dupA3R3 <- read.table("./data/refMME98/A3.htseq.counts.txt")
@ 

Merge all mapped reads to MMETSP0098 reference transcriptome before discarding duplicates (ie, raw counts).
<<prediscardR31>>=
ref.mme98 <- data.frame(A1 = ref.dupA1R3$V2,
                        A2 = ref.dupA2R3$V2,
                        A3 = ref.dupA3R3$V2,
                        contigs = ref.dupA1R3$V1)
@ 

Add the length values to each contig mapped to MMETsp0098. But first remove extra rows.
<<mappedx23>>=
nr <- nrow(ref.mme98)
ref.mme98 <- ref.mme98[1:(nr-5), ]
tail(ref.mme98)
@


Load the number of mapped reads to the MMETSP0099\_2 transcriptome before discarding duplicates.
<<prediscardR34>>=
ref.dupA1R4 <- read.table("./data/refMME992/A1.htseq.counts.txt")
ref.dupA2R4 <- read.table("./data/refMME992/A2.htseq.counts.txt")
ref.dupA3R4 <- read.table("./data/refMME992/A3.htseq.counts.txt")
@

Merge all mapped reads to MMETSP0099\_2 reference transcriptome before discarding duplicates (ie, raw counts).
<<prediscardR314>>=
ref.mme992 <- data.frame(A1 = ref.dupA1R4$V2,
                        A2 = ref.dupA2R4$V2,
                        A3 = ref.dupA3R4$V2,
                        contigs = ref.dupA1R4$V1)
@ 

Add the length values to each contig mapped to MMETsp0099\_2. But first remove extra rows.
<<mappedx234>>=
nr <- nrow(ref.mme992)
ref.mme992 <- ref.mme992[1:(nr-5), ]
tail(ref.mme992)
@ 

Load the number of mapped reads to SR v015 genome before discarding duplicates.
<<prediscardR345>>=
ref.dupA1R5 <- read.table("./data/refGenomV015/A1.htseq.counts.txt")
ref.dupA2R5 <- read.table("./data/refGenomV015/A2.htseq.counts.txt")
ref.dupA3R5 <- read.table("./data/refGenomV015/A3.htseq.counts.txt")
@

Merge all mapped reads to SR v015 reference genome before discarding duplicates (ie, raw counts).
<<prediscardR3145>>=
ref.genomv015 <- data.frame(A1 = ref.dupA1R5$V2,
                        A2 = ref.dupA2R5$V2,
                        A3 = ref.dupA3R5$V2,
                        contigs = ref.dupA1R5$V1)
@ 

Add the length values to each contig mapped to SR v015 reference genome. But first remove extra rows.
<<mappedx2345>>=
nr <- nrow(ref.genomv015)
ref.genomv015 <- ref.genomv015[1:(nr-5), ]
tail(ref.genomv015)
@ 


After aligning the reads to a reference duplicates must be removed. Testing was done with different reference transcriptomes and genomes to assess the strength of the parameters used for removing the duplicate reads and reducing bias for better coverage.

First load the sample reads mapped to reference genome (without duplication) of Steve Roberts.
<<dupl1>>=
nodupA1R1 <- read.table("./data/nodupR1/A1.htseq.nodup.counts.txt")
nodupA2R1 <- read.table("./data/nodupR1/A2.htseq.nodup.counts.txt")
nodupA3R1 <- read.table("./data/nodupR1/A3.htseq.nodup.counts.txt")
@ 

Second load the sample reads mapped to reference transcriptome (withtout duplication) of Steve Roberts.
<<dupl2>>=
nodupA1R2 <- read.table("./data/nodupR2/A1.htseq.nodup.counts.txt")
nodupA2R2 <- read.table("./data/nodupR2/A2.htseq.nodup.counts.txt")
nodupA3R2 <- read.table("./data/nodupR2/A3.htseq.nodup.counts.txt")
@ 

Third load the sample reads mapped to reference transcriptome (without duplication) of MMESTO0098.
<<dupl3>>=
nodupA1R3 <- read.table("./data/nodupR3/A1.htseq.counts.nodup.txt")
nodupA2R3 <- read.table("./data/nodupR3/A2.htseq.counts.nodup.txt")
nodupA3R3 <- read.table("./data/nodupR3/A3.htseq.counts.nodup.txt")
@ 

Forth load of sample reads mapped to reference transcriptome MMETSP0099\_2.
<<dupl4>>=
nodupA1R4 <- read.table("./data/nodupR4/A1.htseq.counts.nodup.txt")
nodupA2R4 <- read.table("./data/nodupR4/A2.htseq.counts.nodup.txt")
nodupA3R4 <- read.table("./data/nodupR4/A3.htseq.counts.nodup.txt")
@ 

Forth load of sample reads mapped to reference SR genome v015 with approximately 21,000 contigs.
<<dupl44>>=
nodupA1R5 <- read.table("./data/nodupR5/A1.htseq.counts.nodup.txt")
nodupA2R5 <- read.table("./data/nodupR5/A2.htseq.counts.nodup.txt")
nodupA3R5 <- read.table("./data/nodupR5/A3.htseq.counts.nodup.txt")
@ 

Merge mapped reads relative to the followingf references.
\begin{itemize}
\item R1 = genome of QPX (steve roberts, 555 contigs)
\item R2 = transcriptome of QPX (steve roberts)
\item R3 = transcriptome of QPX MMETSP0098, New York strain
\item R4 = transcriptome of QPX MMETSP0099\_2, Virginia strain
\item R5 = genome of QPX (steve roberts v015, approx. 21,000 contigs)
\end{itemize}
<<>>=
allR1 <- data.frame(A1n = nodupA1R1$V2,
                  A2n = nodupA2R1$V2,
                  A3n = nodupA3R1$V2,
                  reference = rep("genomSRv017", nrow(nodupA1R1)),
                    contigs = nodupA1R1$V1)
allR1 <- allR1[1:555, ]

allR2 <- data.frame(A1n = nodupA1R2$V2,
                  A2n = nodupA2R2$V2,
                  A3n = nodupA3R2$V2,
                  reference = rep("trxSRv022", nrow(nodupA1R2)),
                    contigs = nodupA1R2$V1)
allR2 <- allR2[1:11774, ]

allR3 <- data.frame(A1n = nodupA1R3$V2,
                  A2n = nodupA2R3$V2,
                  A3n = nodupA3R3$V2,
                  reference = rep("trxMME98", nrow(nodupA1R3)),
                    contigs = nodupA1R3$V1)
allR3 <- allR3[1:15489, ]

allR4 <- data.frame(A1n = nodupA1R4$V2,
                  A2n = nodupA2R4$V2,
                  A3n = nodupA3R4$V2,
                  reference = rep("trxMME992", nrow(nodupA1R4)),
                    contigs = nodupA1R4$V1)
allR4 <- allR4[1:c(nrow(nodupA1R4)-5), ]

allR5 <- data.frame(A1n = nodupA1R5$V2,
                  A2n = nodupA2R5$V2,
                  A3n = nodupA3R5$V2,
                  reference = rep("genomSRv015", nrow(nodupA1R5)),
                    contigs = nodupA1R5$V1)
allR5 <- allR5[1:c(nrow(nodupA1R5)-5), ]


 
@ 

Put before /after duplicates removal in one dataset for genome of Steve Roberts.
<<genomexxc>>=
genomeSR <- merge(ref.genome.mix[, 1:5], allR1)
head(genomeSR)
rownames(genomeSR) <- genomeSR$contigs
genomeSR <- t(genomeSR[, -c(1,9)])
genomeSR[, 1:3]
genomeSR <- data.frame(genomeSR,
                       y = c(2, rep(0,3), rep(1,3)))
@

Put the before /after duplicates removal in one datasetfor transcriptome of SR.
<<transcriptomexcc>>=
transcriptomeSR <- merge(ref.transcriptome.mix[, 1:5], allR2)
head(transcriptomeSR)
@ 


Present difference for each sample mapped to the references. First merge all samples before /after duplicates were removed.
<<ref123>>=
allRefs <- rbind(allR1, allR2, allR3, allR4, allR5)
dim(allRefs)
summary(allRefs$reference)

allRefs.raw <- rbind(ref.genome.mix[, 3:5],
                     ref.transcriptome.mix[, 3:5],
                     ref.mme98[, 1:3],
                     ref.mme992[, 1:3],
                     ref.genomv015[, 1:3])
dim(allRefs.raw)

allDF <- cbind(allRefs, allRefs.raw)
allDF[sample(1:20000, 5), ]
@ 

Plot the difference before and after duplicates were discarded. The number of mapped reads to the reference contigs is descriptive for any bias in contig assembly. For example in the case of SR genome v017, more than 20 \% of A1, A2, A3 reads align to a small set of contigs. The best distribution is a constant one.

Even though we did not plot length of contigs, the analyzes above demonstrate that length is linearly correlated to the number of mapped reads. Therefore, peaks indicate a specific preference that reads have to map to an assembled reference.
\marginnote{\small\color{blue}$\Lsh$ A high resolution version of the plot below can be found in the Supplemental Information}[.1cm]
<<summaryPlot2, results='hide'>>=
custom.colors <- c(col1 = "#762a83", 
                   col2 = "#1b7837", 
                   col3 = "#ef8a62",
                   col4 = "#2166ac",
                   col5 = "#8c510a",
                   col6 = "#e6ab02")

histogram( ~ A1 + A2 + A3 | c('A1n', 'A2n', 'A3n'),
     data = allDF,
     nint = 50,
     scales = list(log = 2),
     type = "p",
     ylim = c(0,25),
     groups = allDF$reference,
     panel = function(...) panel.superpose(..., 
         panel.groups = panel.histogram,
         col = custom.colors, 
         alpha = 1),
     auto.key=list(columns=3,
         rectangles = FALSE,
         col = custom.colors),
          main = 'Peaks indicate bias mapping to one contig length',
          ylab = 'Percent of total number of mapped reads to the reference (%)',
          xlab = 'Number of mapped reads for each reference contig (log10)'
     )

@ 


\section{Extracting QPX reads}
\label{sec:exctraction}

Load file with read counts per sample.
\begin{itemize}
\item A samples as nodule tissue
\item B samples as non nodule diseased tissue
\item C samples as non nodule non diseased tissue
\end{itemize}
Raw reads have been trimmed, mapped to reference genome (Steve Roberts v15 with 21280 contigs), sorted by position on the genome, and cleaned from duplicated reads.\marginnote{\small\color{blue}$\Lsh$ Hypothetically these raw reads includes specific QPX reads}[.1cm]
<<counts1>>=
reads.counts <- read.xlsx("./data/mappedNodules.xlsx", sheetIndex = 1)
reads.counts$fill <- gl(3, 3, 9, labels = c("a", "b", "c"))
ggplot(reads.counts,
       aes(x = sample,
           y = raw.reads,
           fill = fill)) +
    coord_flip() +
        theme_bw() +
            geom_bar(stat = "identity") +
                geom_text(aes(x = sample,
                              y = raw.reads,
                              ymax = raw.reads,
                              label = raw.reads,
                              size = 2,
                              hjust = 1.3)) + 
                    scale_fill_hue(c = 40, l = 60) +
                labs(x = "Number of raw sequenced reads",
                     y = "Sequenced replicated samples")
@ 

Number of reads that mapped to the reference genome of QPX.
\marginnote{\small\color{blue}$\Lsh$ These reads are probably those of QPXs'}[.1cm]
<<counts2>>=
ggplot(reads.counts,
       aes(x = sample,
           y = mapped.reads,
           fill = fill)) +
    geom_bar(stat = "identity") +
        geom_text(aes(x = sample,
                      y = mapped.reads,
                      ymax = mapped.reads,
                      label = mapped.reads,
                      hjust = 1,
                      size = 2)) +
            coord_flip() +
                theme_bw() +
                    scale_fill_grey(start = .4, end = .9) + 
                labs(x = "Number of filtered and mapped reads",
                     y = "Sequenced replicated samples")

@ 

\subsection{QPX genes assembled without hosts genes}
\label{subsec:mapped}
Mapped reads to the QPX reference are than assembled into contigs (ie, the reads showing in the chart above).
\marginnote{\small\color{blue}$\Lsh$ These contigs must be specific transcripts to QPX}[.1cm]
<<counts3>>=
read.xlsx("./data/mappedNodules.xlsx", sheetIndex = 2) %>%
    gather("category", "counts", 3:7) %>%
      ggplot(aes(x = sample,
                 y = counts,
                 fill = sample)) + 
    geom_bar(stat = "identity") +
        theme_bw() +
            facet_wrap( ~ category, 
                       ncol = 2, 
                       scales = "free") + 
                theme(legend.position = "top") +
            labs(x = "Samples merged by genomic position",
                 y = "Number of filtered reads") +
    scale_fill_brewer(type = "qual", palette = 6)
@ 

All contigs were than aligned to the reference genome QPX. The chart shows the number of contigs that align with an increasing length of 100>200>300>400>500.
\marginnote{\small\color{blue}$\Lsh$ Helps discard misassembled contigs or non QPX ones}[.1cm]
<<counts4>>=
read.xlsx("./data/mappedNodules.xlsx", sheetIndex = 4) %>%
    gather("category", "count", 3:7) %>%
      ggplot(aes(x = sample,
           y = count,
           fill = category)) +
    theme_bw() +
        geom_bar(stat = "identity",
                 position = "dodge") +
            facet_wrap( ~ blat, ncol = 1, scale = "free") +
#                scale_fill_manual(values = brewer.pal(5, "Greens")) +
            labs(x = "Samples merged by genomic position",
                 y = "Number of contigs") +
    scale_fill_brewer(type = "qual", palette = 6)
@ 

All contigs were than translated to peptides in 6 frames. Each peptide was than aligned to the whole PFAM library (v28, date: Jul 14 2015).
<<counts5>>=
read.xlsx("./data/mappedNodules.xlsx", sheetIndex = 3) %>%
    gather("category", "count", 3:5) %>%
      ggplot(aes(x = category,
           y = count,
           fill = pfam)) +
    geom_bar(stat = "identity",
             position = "dodge") +
        theme_bw() + 
            facet_wrap( ~ sample, ncol = 1,
                       scales = "free") +
            labs(x = "Evalue for sequence similarity alignement to Pfam",
                 y = "Number of domains or contigs") + 
    scale_fill_brewer(type = "qual", palette = 6)

@

\subsection{Evaluating identified QPX contigs with sequence similarities}
\label{subsec:blast}
BLAST is used at this step to align the contigs found to non redundant (NR), nucleotide (NT), and swissprot databases. Contigs were translated into peptide sequencing with EMBOSS \textit{transeq} in all 6 possible frames.
All contigs were mapped to genome v15 of S. Roberts. Top hit sequences were filtered either with an evalue score, the percentage of identity between query and target sequences, and the number of mismatches found in the aligned region.
<<blast1>>=
read.xlsx("./data/blast.xlsx", sheetIndex = 1) %>%
    gather("options", "counts", 4:12) %>%
      ggplot(aes(x = sample,
           y = counts,
           fill = options)) + 
    geom_bar(stat = "identity",
             position = "dodge") +
    theme_bw() + 
#    geom_text(aes(x = sample,
#                  y = counts,
#                  ymax = counts,
#                  label = counts,
#                  size = 1,
#                  hjust = .5),
#              position = position_dodge(width = 1)) +
    facet_wrap( ~ ncbi, ncol = 1,
               scales = 'free') + 
    labs(x = "Sequenced samples",
         y = "Number of contigs found by BLAST similarity search") +
    scale_fill_brewer(type = "qual",
                      palette = 6)
@ 

Sequences from A, B, C samples are also aligned to 10 other databases. We used interpro accession numbers to get GO-terms too.
We show below the number of contigs if we filter them only by e-value. The no-filter label represent the total number of sequences per database.
<<interpro1>>=
read.xlsx("./data/interpro.xlsx", sheetIndex = 1) %>%
    gather("filters", "value", 2:5) %>%
      ggplot(aes(x = sample,
           y = value,
           fill = filters)) + 
    geom_bar(stat = "identity",
             position = "dodge") + 
    theme_bw() +
        facet_wrap( ~ database,
               ncol = 2,
               scales = "free") + 
    labs(x = "RNAseq Samples",
         y = "Number of annotated contigs found by protein similarity search") + 
    scale_fill_brewer(type = "qual",
                      palette = 6)
@ 

We show here the number of contigs annotated by database and filtered by both evalue and the length of the similarity between query and target sequences.
<<interpro2, out.width='1\\linewidth'>>=
read.xlsx("./data/interpro.xlsx", sheetIndex = 2) %>%
    gather("filters", "value", 3:7) %>%
    ggplot(aes(x = database,
               y = value,
               fill = filters)) + 
                   theme_bw() +
                       geom_bar(stat = "identity",
                                position = "dodge") + 
                       facet_wrap( ~ sample + option, 
                                  ncol = 3,
                                  scales = "free") +
                       labs(x = "Database used for annotation",
                            y = "Number of annotated contigs") +
                       scale_fill_brewer(type = "qual",
                                         palette = 6) + 
        theme(legend.position = "top",
          axis.text.x = element_text(angle = 90,
                                     vjust = .5,
                                     size = 4))

@ 



\section{Removing clam genes from QPX inferred genes}
\label{sec:clamGenes}
For each sequenced we assembled a list of genes. A-list theoretically contains QPX genes, B- and C- contain mostly clam genes. Confidence in the A-list is only valid if clam genes were discarded from, and QPX only genes remained.

The same strategy of contig assembly is carried out for clam. A, B, C raw reads are mapped to clam reference transcriptome. Only the mapped reads are used to assemble 3 lists of hypothetically clam genes. There is many genes so HMMER is used to select the ones containing significant protein domains. The selected genes are mapped to the clam reference and only the genes that map without any gap (on the aligned length) are kept.
<<clam1>>=
gapsA <- read.table("./data/A.e10.blat.gaps.clam.txt")
gapsB <- read.table("./data/B.e10.blat.gaps.clam.txt")
gapsC <- read.table("./data/C.e10.blat.gaps.clam.txt")
df <- full_join(gapsA, gapsB, by="V2") %>%
    full_join(gapsC, by="V2")
colnames(df) <- c("A", "Gaps", "B", "C") 
df[, c(2,1,3,4)] %>%
    gather("Sample", "Count", 2:4) %>%
    filter(Gaps<5) %>%
    ggplot(aes(x = Gaps,
               y = Count,
               fill = Sample)) + 
    theme_bw() +
    geom_bar(stat = "identity",
             position = "dodge") + 
    labs(x = "Number of Gaps (minus 1) over the aligned length between 2 contigs",
         y = "Number of assembled contigs") + 
        scale_fill_brewer(type = "qual", palette = 6)
@ 

Get the number of clam contigs from A, B, and C that align to the clam reference. 
\marginnote{\small\color{blue}$\Lsh$ One sample contig can map to several reference contigs. The latter are mainly length-isoforms of 1 gene.}[0cm]
\begin{itemize}
\item A contig can map entirely to a reference.
\item A contig can align to 2 regions of a reference with 1 gap in between
\item A contig can align to \textit{n} regions of a reference with \textit{n-1} gaps in between
\end{itemize}
The blocksize in the chart below is the length of the aligned region between contig and reference in case there is \textbf{no gap} (ie., 1) or there is \textbf{4 gaps} (ie., 5).
\marginnote{\small\color{blue}$\Lsh$ We chose gaps=5 and blocksize=450}[0cm]
<<clam2>>=
read.table("./data/gaps.blocksize.clam.txt", header = T) %>%
    ggplot(aes(x = Sample,
               y = Count,
               fill = factor(Blocksize))) + 
    theme_bw() +
    geom_bar(stat = "identity",
             position = "dodge") +
    facet_wrap( ~ Gaps,
               ncol = 2,
               scales = "free") + 
    labs(x = "Samples assembled into contigs",
         y = "Number of contigs per sample without redundancy") + 
        scale_fill_brewer(type = "qual", palette = 6)
@ 

\subsection{Preprocessing the clam transcriptome}
\label{subsec:clamtrans}
A, B, and C reads were merged and used to assemble one transcriptome (previous study, not here). The raw output transcriptome done in Trinity was then reduced by 40\% and 60\% using different strategy of quality controls (not here). 
\marginnote{\small\color{blue}$\Lsh$ We used the transcriptome reduced by 40 \% only}[-0.7cm]
Transcriptome size, N50, and contig length are shown below for each transcriptome.
\marginnote{\small\color{blue}$\Lsh$ N50 is the mean length of contigs assembled from 50\% of sequenced nucleotides}[0.5cm]
<<clam3>>=
read.table("./data/clam.filtered.trxome.txt", header = T) %>%
    gather("Category", "Count", 2:6) %>%
    ggplot(aes(x = Version,
               y = Count,
               fill = Version)) + 
        theme_bw() + 
        geom_bar(stat = "identity",
                 position = "dodge") + 
        facet_wrap( ~ Category,
                   ncol = 2,
                   scales = "free") +
        labs(x = "Different filtered version of the same clam transcriptome",
             y = "Count") + 
    scale_fill_brewer(type = "qual", palette = 6)
@ 

From the selected transcriptome (40\%) a guided Trinity assembly is done for each of sample which generated 3 separate clam transcriptomes. These 3 raw transcriptomes have lots of contigs, many of which can be discarded.
<<clam4>>=
read.table("./data/clam.trxome.txt", header = T) %>%
    gather("Category", "Count", 2:6) %>%
    ggplot(aes(x = Sample,
               y = Count,
               fill = Sample)) + 
        theme_bw() + 
        geom_bar(stat = "identity",
                 position = "dodge") + 
        facet_wrap( ~ Category,
                   ncol = 2,
                   scales = "free") +
        labs(x = "Transcriptomes specific to each sequenced clam samples",
             y = "Count") + 
    scale_fill_brewer(type = "qual", palette = 6)
@ 


\section{QPX genes remaining after cleanup}
\label{sec:cleanup}
Raw reads of A, B, C samples are mapped to QPX reference genome. The true mapped reads are then assembled into contigs with Trinity genome guided approach. Number of genes resulted for each sample are shown in Section \ref{subsec:mapped}.
These genes are then processed to select \textbf{932, 44, 0} genes/isoforms for QPX in sample A, B, and C respectively.
\begin{enumerate}
\item Remove redundant clam genes common with A, B, C clam assemblies
\item Remove PFAM domains with an e-value higher than $10^{-5}$
\item Remove non-mapped contigs to QPX reference genome that have more than 4 gaps, less than 100 in contig size, and less than 250 in blocksize (if gaps exist)
\end{enumerate}

\section{System Information}
\label{sec:sys_info}
\noindent
The version number of R and packages loaded for generating the vignette were:
<<sessionInfo>>=
###save(list=ls(pattern=".*|.*"),file="PD.Rdata")
sessionInfo()
@ 



\end{linenumbers}
\end{document}
